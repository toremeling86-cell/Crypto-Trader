package com.cryptotrader.domain.model

/**
 * Domain model for a trading strategy
 */
data class Strategy(
    val id: String,
    val name: String,
    val description: String,
    val entryConditions: List<String>,
    val exitConditions: List<String>,
    val positionSizePercent: Double,
    val stopLossPercent: Double,
    val takeProfitPercent: Double,
    val tradingPairs: List<String>,
    val isActive: Boolean = false,
    val createdAt: Long = System.currentTimeMillis(),
    val lastExecuted: Long? = null,
    val totalTrades: Int = 0,
    val successfulTrades: Int = 0,
    val failedTrades: Int = 0,
    val winRate: Double = 0.0,
    val totalProfit: Double = 0.0,
    val riskLevel: RiskLevel = RiskLevel.MEDIUM,
    // AI Analysis and Approval
    val analysisReport: String? = null, // Claude's detailed market analysis and strategy explanation
    val approvalStatus: ApprovalStatus = ApprovalStatus.APPROVED, // For AI-generated strategies
    val source: StrategySource = StrategySource.USER, // Who created the strategy
    // Trailing stop-loss settings
    val useTrailingStop: Boolean = false,
    val trailingStopPercent: Double = 5.0, // Move stop-loss when profit reaches this percent
    // Multi-timeframe analysis settings
    val useMultiTimeframe: Boolean = false,
    val primaryTimeframe: Int = 60, // Main timeframe in minutes (default: 1 hour)
    val confirmatoryTimeframes: List<Int> = listOf(15, 240), // Additional timeframes for confirmation (15m, 4h)
    // Volatility-adjusted stop-loss settings
    val useVolatilityStops: Boolean = false,
    val atrMultiplier: Double = 2.0, // ATR multiplier for stop-loss distance (1.0-4.0)
    // Market regime filtering
    val useRegimeFilter: Boolean = false,
    val allowedRegimes: List<String> = listOf("TRENDING_BULLISH", "TRENDING_BEARISH") // Which regimes to trade in
)

enum class ApprovalStatus {
    PENDING,   // Waiting for user approval
    APPROVED,  // Approved and can be activated
    REJECTED;  // User rejected the strategy

    override fun toString(): String = name
}

enum class StrategySource {
    USER,      // Created by user manually
    AI_CLAUDE; // Generated by Claude AI

    override fun toString(): String = name
}

enum class RiskLevel {
    LOW, MEDIUM, HIGH;

    override fun toString(): String = name

    companion object {
        fun fromString(value: String): RiskLevel {
            return when (value.uppercase()) {
                "LOW" -> LOW
                "MEDIUM" -> MEDIUM
                "HIGH" -> HIGH
                else -> MEDIUM
            }
        }
    }
}

/**
 * Signal generated by a strategy
 */
data class TradeSignal(
    val strategyId: String,
    val pair: String,
    val action: TradeAction,
    val confidence: Double, // 0.0 to 1.0
    val targetPrice: Double? = null,
    val suggestedVolume: Double,
    val reason: String,
    val timestamp: Long = System.currentTimeMillis()
)

enum class TradeAction {
    BUY, SELL, HOLD
}
