package com.cryptotrader.domain.model

import kotlinx.serialization.Serializable

/**
 * Domain model for a trading strategy
 */
data class Strategy(
    val id: String,
    val name: String,
    val description: String,
    val entryConditions: List<String>,
    val exitConditions: List<String>,
    val positionSizePercent: Double,
    val stopLossPercent: Double,
    val takeProfitPercent: Double,
    val tradingPairs: List<String>,
    val isActive: Boolean = false,
    val tradingMode: TradingMode = TradingMode.INACTIVE, // INACTIVE, PAPER, LIVE
    val createdAt: Long = System.currentTimeMillis(),
    val lastExecuted: Long? = null,
    val totalTrades: Int = 0,
    val successfulTrades: Int = 0,
    val failedTrades: Int = 0,
    val winRate: Double = 0.0,
    val totalProfit: Double = 0.0,
    val riskLevel: RiskLevel = RiskLevel.MEDIUM,
    // AI Analysis and Approval
    val analysisReport: String? = null, // Claude's detailed market analysis and strategy explanation
    val approvalStatus: ApprovalStatus = ApprovalStatus.APPROVED, // For AI-generated strategies
    val source: StrategySource = StrategySource.USER, // Who created the strategy
    // Trailing stop-loss settings
    val useTrailingStop: Boolean = false,
    val trailingStopPercent: Double = 5.0, // Move stop-loss when profit reaches this percent
    // Multi-timeframe analysis settings
    val useMultiTimeframe: Boolean = false,
    val primaryTimeframe: Int = 60, // Main timeframe in minutes (default: 1 hour)
    val confirmatoryTimeframes: List<Int> = listOf(15, 240), // Additional timeframes for confirmation (15m, 4h)
    // Volatility-adjusted stop-loss settings
    val useVolatilityStops: Boolean = false,
    val atrMultiplier: Double = 2.0, // ATR multiplier for stop-loss distance (1.0-4.0)
    // Market regime filtering
    val useRegimeFilter: Boolean = false,
    val allowedRegimes: List<String> = listOf("TRENDING_BULLISH", "TRENDING_BEARISH"), // Which regimes to trade in

    // Phase 3C: Performance Tracking & Strategy Lineage
    val metaAnalysisId: Long? = null, // Link to meta-analysis that created this strategy
    val sourceReportCount: Int = 0, // How many expert reports went into creating this
    val maxDrawdown: Double = 0.0, // Maximum drawdown percentage
    val avgWinAmount: Double = 0.0, // Average winning trade amount
    val avgLossAmount: Double = 0.0, // Average losing trade amount
    val profitFactor: Double = 0.0, // Total wins / Total losses
    val sharpeRatio: Double? = null, // Risk-adjusted return metric
    val largestWin: Double = 0.0, // Largest single winning trade
    val largestLoss: Double = 0.0, // Largest single losing trade
    val currentStreak: Int = 0, // Current win/loss streak (positive = wins, negative = losses)
    val longestWinStreak: Int = 0, // Longest consecutive win streak
    val longestLossStreak: Int = 0, // Longest consecutive loss streak
    val performanceScore: Double = 0.0, // Composite performance metric (0.0-100.0)
    val isTopPerformer: Boolean = false, // Flag for top 10% performing strategies
    val totalProfitPercent: Double = 0.0, // Total profit as percentage

    // Kraken Order Execution Settings
    val postOnly: Boolean = false, // Only place maker orders (lower fees, may be rejected)
    val timeInForce: TimeInForce = TimeInForce.GTC, // Order time-in-force behavior
    val orderExpiration: Long? = null, // Expiration timestamp for GTD orders (milliseconds)
    val feeAsset: FeeAsset = FeeAsset.QUOTE, // Prefer fees in base or quote currency
    val maxLeverage: Int? = null, // Maximum leverage to use (null = no leverage, 2-5 for margin)
    val useNativeTrailingStop: Boolean = false, // Use Kraken's native trailing stops vs app-based
    val volumeInQuote: Boolean = false // For market buy orders: specify volume in quote currency
)

enum class ApprovalStatus {
    PENDING,   // Waiting for user approval
    APPROVED,  // Approved and can be activated
    REJECTED;  // User rejected the strategy

    override fun toString(): String = name
}

enum class StrategySource {
    USER,      // Created by user manually
    AI_CLAUDE; // Generated by Claude AI

    override fun toString(): String = name
}

@Serializable
enum class RiskLevel {
    LOW, MEDIUM, HIGH;

    override fun toString(): String = name

    companion object {
        fun fromString(value: String): RiskLevel {
            return when (value.uppercase()) {
                "LOW" -> LOW
                "MEDIUM" -> MEDIUM
                "HIGH" -> HIGH
                else -> MEDIUM
            }
        }
    }
}

/**
 * Time-in-force for orders
 */
@Serializable
enum class TimeInForce {
    GTC,  // Good Till Canceled - remains until filled or cancelled (default)
    IOC,  // Immediate Or Cancel - fill immediately, cancel remainder
    GTD;  // Good Till Date - expires at specified time (requires orderExpiration)

    override fun toString(): String = name

    fun toKrakenFormat(): String = name.lowercase()

    companion object {
        fun fromString(value: String): TimeInForce {
            return when (value.uppercase()) {
                "GTC" -> GTC
                "IOC" -> IOC
                "GTD" -> GTD
                else -> GTC
            }
        }
    }
}

/**
 * Fee currency preference for orders
 */
@Serializable
enum class FeeAsset {
    BASE,   // Fee charged in base currency (e.g., BTC for XBTUSD)
    QUOTE;  // Fee charged in quote currency (e.g., USD for XBTUSD) - default

    override fun toString(): String = name

    fun toKrakenFlag(): String = when (this) {
        BASE -> "fcib"
        QUOTE -> "fciq"
    }

    companion object {
        fun fromString(value: String): FeeAsset {
            return when (value.uppercase()) {
                "BASE" -> BASE
                "QUOTE" -> QUOTE
                else -> QUOTE
            }
        }
    }
}

/**
 * Signal generated by a strategy
 */
data class TradeSignal(
    val strategyId: String,
    val pair: String,
    val action: TradeAction,
    val confidence: Double, // 0.0 to 1.0
    val targetPrice: Double? = null,
    val suggestedVolume: Double,
    val reason: String,
    val timestamp: Long = System.currentTimeMillis()
)

enum class TradeAction {
    BUY, SELL, HOLD
}

/**
 * Trading mode for strategies
 */
@Serializable
enum class TradingMode {
    INACTIVE,  // Strategy saved but not running
    PAPER,     // Simulated trading with fake money
    LIVE;      // Real trading with real money

    override fun toString(): String = name

    companion object {
        fun fromString(value: String): TradingMode {
            return when (value.uppercase()) {
                "INACTIVE" -> INACTIVE
                "PAPER" -> PAPER
                "LIVE" -> LIVE
                else -> INACTIVE
            }
        }
    }
}
